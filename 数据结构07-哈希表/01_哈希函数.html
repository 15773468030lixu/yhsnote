<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>哈希表</title>
</head>
<body>
<script>
    /**
     * 学习其他语言，python很多地方用到hash表，云里雾里的感觉
     * hash表，代码简单，但是理论知识很多，很重要
     * hash表基于数组实现的，但是相对于数组有优势，
     * 数组在插入的时候效率比较低,数组查找的时候基于索引效率非常高，但是基于内容查找效率非常低，数组进行删除操作效率不高，基于内容修改的话效率非常低
     * 这些问题怎么解决？而他经过变换的时候,效率变得非常高，哈希表是个非常伟大的发明，插入删除查找的操作效率非常高
     * 但是哈希表基本上时间固定O1
     * 哈希表缺点：无序 key不允许重复，结构确实是数组，但是画不出来，下标值通过hash函数经过了变换 
     * 应用：保存联系电话和姓名   存储单词信息
     * 给你个名字，通过名字获取对应的下标值，效率就非常非常高，通过hash算法快速定位
     * 保存联系人和电话，把联系人和电话号封装一个对象，在匹配对应的下标值
     * 知道某联系人名字，立马知道电话号码，，，这种东西将名字这种字符串转成下标值的过程叫做hash函数
     * 存储类似于这种信息，使用hash表比较好一点
     * 
     * 
     * 这多有的解决方案都指向字符串转成数组的下标值，即字符转成二进制数字,即单词中每个字符编码求和变成对应的数字
     * 但这里有个问题，多个单词编码求和结果数字相同
     * 幂的连乘   平时使用大于10的数字，用幂的连乘 来表示唯一性比如7654=7*10^3+6*10^2+5*10^2+4*10^1
     * cats3 1 21 19 =49  数字相加的方案会有点   编码里总共27个字符，3*27^3+1*27^2+21*27^1+19*27^0=保证唯一性，但是这又会分配大的内存空间，空间浪费
     * 
     * 结合两种方案的优点：哈希化  ===>把幂的连乘方案系统中得到巨大的整数范围压缩到可接受的数组范围
     * 如何进行压缩？进行取余操作，重复的概率比较小
     * 
     * 哈希化：将大数字转换成数组范围内下标的过程我们称之为哈希化
     * 哈希函数：通常会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数我们称之为哈希函数
     * 哈希表：最终将数据插入到这个数组，对整个结构的封装，我们称之为一个hash表
     * 
     * 通过hash化的下标值依然可能会重复，如何解决这种重复的问题？
     * 1.链地址化：现创建了十个元素的数组，哈希化后30指向第一个元素,后来110哈希化取余得到的下标值跟30是同一个位置，这样就会把30覆盖掉，之后查找30这个信息就会查找不到
     * 这个时候在数组下标这个位置不是单纯存放一个元素,存储一个链表，这样30作为链表第一个元素，110作为链表第二个元素
     * 查找时 先根据哈希后的下标值找到一个位置，取出整个链表，查找当前的一个位置
     * 2.开放地址法：寻找空白的单元格添加重复的数据
     *      线性探测：步长+1
     *      二次探测：步长幂乘
     *      再哈希化：用哈希化的结果，不同的关键词不同的步长不一样具备条件，与第一次哈希函数不相同且输出结果不为0
     * 哈希函数：stepSize=constant-(key%constant) constant是质数，且小于数组容量
     * 
     * 什么是探测的长度？往后找空白单元，到底找几个，所以产生冲突的情况下，存取时间依赖于后面我们的探测长度，探测长度又跟一个名词有关系，叫探测因子
     * 随着填充因子的变大，探测长度也会变大，填充因子又到底是个什么东西呢？
     * 填充因子表示当前哈希表中包含的数据项和整个哈希表的长度的一个比值，比如说当前哈希表长度为10，存放了5个元素，哈希填充因子就是0.5
     * 探测长度决定哈希表的效率
     * 
     * 链地址法效率高一点还是开放地址法的效率高一点？
     * 随着查找的次数变多，成功的概率和失败的概率几乎以指数的形式增长  
     * 二次探测和再哈希性能相当，他们的性能比线性探测好
     * 链地址法的效率相对于来说比开放地址法高
     * 
     * 哈希树使用质数[哈希表的长度、N次幂的底数]会让哈希表更加均匀
     * java哈希表采用的是链地址法，HashMap中为了提高效率，采用的是位运算
     * 平常都是取模元素，方便代码向开放地址法迁移
     * 设计好的哈希函数，一是快速计算，二是均匀分布
    */
    function hashFunc(str, size) {
        // 1.初始化hashCode的值，用于保存比较大的数字
        var hashCode = 0
        // 2.霍纳算法, 来计算hashCode的数值str.charCodeAt(i)获取到每个i单词对应的字符编码
        //没循环一次都会进行一次计算
        for (var i = 0; i < str.length; i++) {
            hashCode = 37 * hashCode + str.charCodeAt(i)
        }
        
        // 3.取模运算
        hashCode = hashCode % size
        return hashCode
    }
//字符串abc准备放到一个长度为7的这样一个数组
    alert(hashFunc("abc", 7)) // 4
    alert(hashFunc("cba", 7)) // 3
    alert(hashFunc("nba", 7)) // 5
    alert(hashFunc("mba", 7)) // 1

</script>
</body>
</html>